# 10733078-Python-hw1\
This article introduces the implementation principle of a bidirectional circular linked list, including class definition, basic attribute methods (such as determining null, length, traversal), and core operations (head insertion, tail addition, arbitrary position insertion, node search and deletion). It shows how to use the bidirectional feature to simplify node operations and discusses its advantages over ordinary bidirectional linked lists.
The summary is generated by CSDN through intelligent technology
The bidirectional circular linked list is developed on the basis of the bidirectional linked list. The last node of the bidirectional linked list points to the starting node, and the previous node of the starting node points to the last node, thus obtaining a bidirectional circular linked list.
A bidirectional circular linked list has more advantages than a bidirectional linked list. There are many optimizations in adding and deleting nodes. Nodes can be added or deleted without looping through the entire linked list from the starting point.
First, define the basic class of the doubly linked list and the basic class of the node: 

 ![image](https://github.com/user-attachments/assets/21f6f0ec-99fc-47f0-a498-339205fab86e)

 class Node:
    def __init__(self, item):
        self.item = item  # 该节点值
        self.next = None   # 连接一下一个节点
        self.prev = None  # 上一个节点值
 
 
class DoubleCircularLinkedList:
    """双向循环列表类"""
    def __init__(self):
        self._head = None

Next, we add the logic of the basic property method. Note that the way to determine whether it is the last node is whether the next node of the last node points to the node pointed to by the head.

class Node:
    def __init__(self, item):
        self.item = item  # 该节点值
        self.next = None   # 连接一下一个节点
        self.prev = None  # 上一个节点值
class DoubleCircularLinkedList:
    """双向循环列表类"""
    def __init__(self):
        self._head = None
 
    @property
    def is_empty(self):
        """
        判断链表是否为空
        :return:
        """
        return not self._head
 
    @property
    def length(self):
        """
        链表长度
        :return:
        """
        if self.is_empty:
            return 0
        else:
            cur = self._head.next
            n = 1
            while cur != self._head:
                cur = cur.next
                n += 1
            return n
 
    @property
    def ergodic(self):
        """
        遍历链表
        :return:
        """
        if self.is_empty:
           raise ValueError("ERROR NULL")
        else:
            cur = self._head.next
            print(self._head.item)
            while cur != self._head:
                print(cur.item)
                cur = cur.next

There are several core points in the operation of linked list class. The first is to determine whether it is the last node through the relevant characteristics of the linked list, such as the next attribute of the last node of a one-way linked list is None, and the next attribute of the last node of a one-way circular linked list is equal to the head node; the second is to use a cursor to replace the node pointing. Sometimes two cursors are needed when operating nodes, but only one cursor is needed for bidirectional nodes. The upper and lower nodes can be found through the attributes of the current node.
Continue to add methods to the object: insert a node at the head, add a node at the tail, and insert a node at any position.

class Node:
    def __init__(self, item):
        self.item = item  # 该节点值
        self.next = None   # 连接一下一个节点
        self.prev = None  # 上一个节点值
 
 
class DoubleCircularLinkedList:
    """双向循环列表类"""
    def __init__(self):
        self._head = None
 
    @property
    def is_empty(self):
        """
        判断链表是否为空
        :return:
        """
        return not self._head
 
    @property
    def length(self):
        """
        链表长度
        :return:
        """
        if self.is_empty:
            return 0
        else:
            cur = self._head.next
            n = 1
            while cur != self._head:
                cur = cur.next
                n += 1
            return n
 
    @property
    def ergodic(self):
        """
        遍历链表
        :return:
        """
        if self.is_empty:
           raise ValueError("ERROR NULL")
        else:
            cur = self._head.next
            print(self._head.item)
            while cur != self._head:
                print(cur.item)
                cur = cur.next
 
    def add(self, item):
        """
        头部添加节点
        :return:
        """
        node = Node(item)
        if self.is_empty:
            node.next = node
            node.prev = node
            self._head = node
        else:
            node.next = self._head
            node.prev = self._head.prev
            self._head.prev.next = node
            self._head.prev = node
            self._head = node
 
    def append(self, item):
        """
        尾部添加节点
        :param item:
        :return:
        """
        if self.is_empty:
            self.add(item)
        else:
            node = Node(item)
            cur = self._head.next
            while cur.next != self._head:
                cur = cur.next
            cur.next = node
            node.prev = cur
            node.next = self._head
            self._head.prev = node
 
    def insert(self, index, item):
        """
        任意位置插入节点
        :param item:
        :return:
        """
        if index == 0:
            self.add(item)
        elif index+1 >= self.length:
            self.append(item)
        else:
            cur = self._head.next
            n = 1
            while cur.next != self._head:
                if n == index:
                    break
                cur = cur.next
                n += 1
            node = Node(item)
            node.prev = cur.prev
            cur.prev.next = node
            node.next = cur
            cur.prev = node

接着实现判断节点是否存在以及删除指定节点。
 


class DoubleCircularLinkedList:
    """双向循环列表类"""
    def __init__(self):
        self._head = None
 
    @property
    def is_empty(self):
        """
        判断链表是否为空
        :return:
        """
        return not self._head
 
    @property
    def length(self):
        """
        链表长度
        :return:
        """
        if self.is_empty:
            return 0
        else:
            cur = self._head.next
            n = 1
            while cur != self._head:
                cur = cur.next
                n += 1
            return n
 
    @property
    def ergodic(self):
        """
        遍历链表
        :return:
        """
        if self.is_empty:
           raise ValueError("ERROR NULL")
        else:
            cur = self._head.next
            print(self._head.item)
            while cur != self._head:
                print(cur.item)
                cur = cur.next
 
    def add(self, item):
        """
        头部添加节点
        :return:
        """
        node = Node(item)
        if self.is_empty:
            node.next = node
            node.prev = node
            self._head = node
        else:
            node.next = self._head
            node.prev = self._head.prev
            self._head.prev.next = node
            self._head.prev = node
            self._head = node
 
    def append(self, item):
        """
        尾部添加节点
        :param item:
        :return:
        """
        if self.is_empty:
            self.add(item)
        else:
            node = Node(item)
            cur = self._head.next
            while cur.next != self._head:
                cur = cur.next
            cur.next = node
            node.prev = cur
            node.next = self._head
            self._head.prev = node
 
    def insert(self, index, item):
        """
        任意位置插入节点
        :param item:
        :return:
        """
        if index == 0:
            self.add(item)
        elif index+1 >= self.length:
            self.append(item)
        else:
            cur = self._head.next
            n = 1
            while cur.next != self._head:
                if n == index:
                    break
                cur = cur.next
                n += 1
            node = Node(item)
            node.prev = cur.prev
            cur.prev.next = node
            node.next = cur
            cur.prev = node
 
    def search(self, item):
        """
        查找节点是否存在
        :return:
        """
        if self.is_empty:
            return False
        else:
            cur = self._head.next
            if self._head.item == item:
                return True
            else:
                while cur != self._head:
                    if cur.item == item:
                        return True
                    else:
                        cur = cur.next
                return False
 
    def delete(self, item):
        """
        删除指定值的节点
        :param item:
        :return:
        """
        if self.is_empty:
            raise ValueError("ERROR NULL")
        else:
            if self._head.item == item:
                if self.length == 1:
                    self._head = Node
                else:
                    self._head.prev.next = self._head.next
                    self._head.next.prev = self._head.prev
                    self._head = self._head.next
            cur = self._head.next
            while cur != self._head:
                if cur.item == item:
                    cur.prev.next = cur.next
                    cur.next.prev = cur.prev
                cur = cur.next
 ![image](https://github.com/user-attachments/assets/1c87351a-c647-4525-8377-295caaa0350e)


